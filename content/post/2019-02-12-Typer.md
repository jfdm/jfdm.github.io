---
title: "Computing Types with Idris & Linking Specifications with Implementations."
tags: ["idris","dependent-types"]
date: 2019-02-12
---

Within dependently typed languages such as Idris types:

+ are *first-class*
+ can *depend on values*; and
+ can be computed.

With this last point we see that the Idris language doesn't have special constructs to specify type synonyms: We write functions to compute the type.
Similarly, we can compute type signatures from programs.
A common example seen is the type-safe `printf` function in which an EDSL describes the format string and is then computed to construct a type signature.

In this post I want to show how we can use dependent types to compute simple type signatures.

## A Data Type for Type Signatures

First we define `Typer` a simple indexed algebraic data type to represent a type signature.

<pre>
<span class="idris-keyword">data</span><!-- closing Keyword--> <span class="idris-type" title="Type -> Type">Typer</span><!-- closing Name TypeConstructor "" "Type -> Type"--> : <span class="idris-type" title="The type of types Type">Type</span><!-- closing Name TypeConstructor "The type of types" "Type"--> -&gt; <span class="idris-type" title="The type of types Type">Type</span><!-- closing Name TypeConstructor "The type of types" "Type"--> <span class="idris-keyword">where</span><!-- closing Keyword-->
   <span class="idris-data" title="Typer a -> (a -> Typer b) -> Typer b">Let</span><!-- closing Name Constructor "" "Typer a -> (a -> Typer b) -> Typer b"--> : (<span class="idris-type" title="Type -> Type">Typer</span><!-- closing Name TypeConstructor "" "Type -> Type"--> <span class="idris-bound">a</span><!-- closing Bound False-->) -&gt; (<span class="idris-bound">a</span><!-- closing Bound False--> -&gt; <span class="idris-type" title="Type -> Type">Typer</span><!-- closing Name TypeConstructor "" "Type -> Type"--> <span class="idris-bound">b</span><!-- closing Bound False-->) -&gt; <span class="idris-type" title="Type -> Type">Typer</span><!-- closing Name TypeConstructor "" "Type -> Type"--> <span class="idris-bound">b</span><!-- closing Bound False-->
   <span class="idris-data" title="(type : Type) -> Typer type">Return</span><!-- closing Name Constructor "" "(type : Type) -> Typer type"--> : (<span class="idris-bound">type</span><!-- closing Bound False--> : <span class="idris-type" title="The type of types Type">Type</span><!-- closing Name TypeConstructor "The type of types" "Type"-->) -&gt; <span class="idris-type" title="Type -> Type">Typer</span><!-- closing Name TypeConstructor "" "Type -> Type"--> <span class="idris-bound">type</span><!-- closing Bound False-->
   <span class="idris-data" title=" (type : Type) -> Maybe String -> Typer type">Param</span><!-- closing Name Constructor "" "(type : Type) -> Maybe String -> Typer type"-->  : (<span class="idris-bound">type</span><!-- closing Bound False--> : <span class="idris-type" title="The type of types Type">Type</span><!-- closing Name TypeConstructor "The type of types" "Type"-->) -&gt; <span class="idris-type" title="An optional value. This can be used to represent the possibility of failure, where a function may return a value, or not. Type -> Type">Maybe</span><!-- closing Name TypeConstructor "An optional value. This can be used to represent\nthe possibility of failure, where a function may\nreturn a value, or not." "Type -> Type"--> <span class="idris-type" title="Strings in some unspecified encoding Type">String</span><!-- closing Name TypeConstructor "Strings in some unspecified encoding" "Type"--> -&gt; <span class="idris-type" title=" Type -> Type">Typer</span><!-- closing Name TypeConstructor "" "Type -> Type"--> <span class="idris-bound">type</span><!-- closing Bound False-->
   <span class="idris-data" title=" Typer ()">SemiColon</span><!-- closing Name Constructor "" "Typer ()"--> : <span class="idris-type" title="Type -> Type">Typer</span><!-- closing Name TypeConstructor "" "Type -> Type"--> <span class="idris-type" title="The canonical single-element type, also known as the trivially true proposition. Type">()</span><!-- closing Name TypeConstructor "The canonical single-element type, also known as\nthe trivially true proposition." "Type"-->
</pre>

We use `Let` to represent sequencing of expressions.
`Return` indicates the function's return type, and `Param` represents a function parameter that *might* have documentation.
`SemiColon` signifies the end of the signature.

Now this is not the best representation for this data type!
We can present multiple returns declarations, and said declarations can be interleaved between parameters.
We can revisit the type of `Typer` to introduce more machinery to reason about the substructural properties of `Typer`, but I leave that as an exercise for the reader.

To get Idris' Do-notation we use `Let` as an implementation for `(>>=)`.

<pre>
<span class="idris-function" title="Typer a -> (a -> Typer b) -> Typer b">(&gt;&gt;=)</span><!-- closing Name Function "" "Typer a -> (a -> Typer b) -> Typer b"--> : (<span class="idris-type" title=" Type -> Type">Typer</span><!-- closing Name TypeConstructor "" "Type -> Type"--> <span class="idris-bound">a</span><!-- closing Bound False-->) -&gt; (<span class="idris-bound">a</span><!-- closing Bound False--> -&gt; <span class="idris-type" title="Type -> Type">Typer</span><!-- closing Name TypeConstructor "" "Type -> Type"--> <span class="idris-bound">b</span><!-- closing Bound False-->) -&gt; <span class="idris-type" title="Type -> Type">Typer</span><!-- closing Name TypeConstructor "" "Type -> Type"--> <span class="idris-bound">b</span><!-- closing Bound False-->
<span class="idris-function" title="Typer a -> (a -> Typer b) -> Typer b">(&gt;&gt;=)</span><!-- closing Name Function "" "Typer a -> (a -> Typer b) -> Typer b"--> = <span class="idris-data" title="Typer a -> (a -> Typer b) -> Typer b">Let</span><!-- closing Name Constructor "" "Typer a -> (a -> Typer b) -> Typer b"-->
</pre>

With `Typer` we can specify simple functions that compute concrete type signatures.
I haven't looked at how we can construct polymorphic type signatures.

### Examples

We can use `Typer` to write type signatures.

#### Append
<pre>
<span class="idris-function" title="
Nat -> Nat -> Type -> Typer ()">Append</span><!-- closing Name Function "" "Nat -> Nat -> Type -> Typer ()"--> : (<span class="idris-bound">n</span><!-- closing Bound False-->,<span class="idris-bound">m</span><!-- closing Bound False--> : <span class="idris-type" title="Natural numbers: unbounded, unsigned integers
which can be pattern matched.
Type">Nat</span><!-- closing Name TypeConstructor "Natural numbers: unbounded, unsigned integers\nwhich can be pattern matched." "Type"-->) -&gt; (<span class="idris-bound">type</span><!-- closing Bound False--> : <span class="idris-type" title="The type of types
Type">Type</span><!-- closing Name TypeConstructor "The type of types" "Type"-->) -&gt; <span class="idris-type" title="
Type -> Type">Typer</span><!-- closing Name TypeConstructor "" "Type -> Type"--> <span class="idris-type" title="The canonical single-element type, also known as
the trivially true proposition.
Type">()</span><!-- closing Name TypeConstructor "The canonical single-element type, also known as\nthe trivially true proposition." "Type"-->
<span class="idris-function" title="
Nat -> Nat -> Type -> Typer ()">Append</span><!-- closing Name Function "" "Nat -> Nat -> Type -> Typer ()"--> <span class="idris-bound">n</span><!-- closing Bound False--> <span class="idris-bound">m</span><!-- closing Bound False--> <span class="idris-bound">a</span><!-- closing Bound False--> = <span class="idris-keyword">do</span><!-- closing Keyword-->
  <span class="idris-data" title="
(type : Type) -> Maybe String -> Typer type">Param</span><!-- closing Name Constructor "" "(type : Type) -> Maybe String -> Typer type"--> (<span class="idris-type" title="Vectors: Generic lists with explicit length in the
type
Nat -> Type -> Type">Vect</span><!-- closing Name TypeConstructor "Vectors: Generic lists with explicit length in the\ntype" "Nat -> Type -> Type"--> <span class="idris-bound">n</span><!-- closing Bound False--> <span class="idris-bound">a</span><!-- closing Bound False-->) <span class="idris-data" title="No value stored
Maybe a">Nothing</span><!-- closing Name Constructor "No value stored" "Maybe a"-->
  <span class="idris-data" title="
(type : Type) -> Maybe String -> Typer type">Param</span><!-- closing Name Constructor "" "(type : Type) -> Maybe String -> Typer type"--> (<span class="idris-type" title="Vectors: Generic lists with explicit length in the
type
Nat -> Type -> Type">Vect</span><!-- closing Name TypeConstructor "Vectors: Generic lists with explicit length in the\ntype" "Nat -> Type -> Type"--> <span class="idris-bound">m</span><!-- closing Bound False--> <span class="idris-bound">a</span><!-- closing Bound False-->) <span class="idris-data" title="No value stored
Maybe a">Nothing</span><!-- closing Name Constructor "No value stored" "Maybe a"-->
  <span class="idris-data" title="
(type : Type) -> Typer type">Return</span><!-- closing Name Constructor "" "(type : Type) -> Typer type"--> (<span class="idris-type" title="Vectors: Generic lists with explicit length in the
type
Nat -> Type -> Type">Vect</span><!-- closing Name TypeConstructor "Vectors: Generic lists with explicit length in the\ntype" "Nat -> Type -> Type"--> (<span class="idris-function" title="Add two natural numbers.
Nat -> Nat -> Nat">plus</span><!-- closing Name Function "Add two natural numbers." "Nat -> Nat -> Nat"--> <span class="idris-bound">n</span><!-- closing Bound False--> <span class="idris-bound">m</span><!-- closing Bound False-->) <span class="idris-bound">a</span><!-- closing Bound False-->)
  <span class="idris-data" title="
Typer ()">SemiColon</span><!-- closing Name Constructor "" "Typer ()"-->
</pre>

#### Concat

In this next example we present the definition of a function to concatenate two lists with length.

<pre>
<span class="idris-function" title="
Nat -> Nat -> Type -> Typer ()">Concat</span><!-- closing Name Function "" "Nat -> Nat -> Type -> Typer ()"--> : (<span class="idris-bound">m</span><!-- closing Bound False-->,<span class="idris-bound">n</span><!-- closing Bound False-->: <span class="idris-type" title="Natural numbers: unbounded, unsigned integers
which can be pattern matched.
Type">Nat</span><!-- closing Name TypeConstructor "Natural numbers: unbounded, unsigned integers\nwhich can be pattern matched." "Type"-->) -&gt; (<span class="idris-bound">type</span><!-- closing Bound False--> : <span class="idris-type" title="The type of types
Type">Type</span><!-- closing Name TypeConstructor "The type of types" "Type"-->) -&gt; <span class="idris-type" title="
Type -> Type">Typer</span><!-- closing Name TypeConstructor "" "Type -> Type"--> <span class="idris-type" title="The canonical single-element type, also known as
the trivially true proposition.
Type">()</span><!-- closing Name TypeConstructor "The canonical single-element type, also known as\nthe trivially true proposition." "Type"-->
<span class="idris-function" title="
Nat -> Nat -> Type -> Typer ()">Concat</span><!-- closing Name Function "" "Nat -> Nat -> Type -> Typer ()"--> <span class="idris-bound">m</span><!-- closing Bound False--> <span class="idris-bound">n</span><!-- closing Bound False--> <span class="idris-bound">a</span><!-- closing Bound False--> = <span class="idris-keyword">do</span><!-- closing Keyword-->
  <span class="idris-data" title="
(type : Type) -> Maybe String -> Typer type">Param</span><!-- closing Name Constructor "" "(type : Type) -> Maybe String -> Typer type"--> (<span class="idris-type" title="Vectors: Generic lists with explicit length in the
type
Nat -> Type -> Type">Vect</span><!-- closing Name TypeConstructor "Vectors: Generic lists with explicit length in the\ntype" "Nat -> Type -> Type"--> <span class="idris-bound">m</span><!-- closing Bound False--> (<span class="idris-type" title="Vectors: Generic lists with explicit length in the
type
Nat -> Type -> Type">Vect</span><!-- closing Name TypeConstructor "Vectors: Generic lists with explicit length in the\ntype" "Nat -> Type -> Type"--> <span class="idris-bound">n</span><!-- closing Bound False--> <span class="idris-bound">a</span><!-- closing Bound False-->)) <span class="idris-data" title="No value stored
Maybe a">Nothing</span><!-- closing Name Constructor "No value stored" "Maybe a"-->
  <span class="idris-data" title="
(type : Type) -> Typer type">Return</span><!-- closing Name Constructor "" "(type : Type) -> Typer type"--> (<span class="idris-type" title="Vectors: Generic lists with explicit length in the
type
Nat -> Type -> Type">Vect</span><!-- closing Name TypeConstructor "Vectors: Generic lists with explicit length in the\ntype" "Nat -> Type -> Type"--> (<span class="idris-bound">m</span><!-- closing Bound False--> <span class="idris-function" title="
Num ty => ty -> ty -> ty">*</span><!-- closing Name Function "" "Num ty => ty -> ty -> ty"--> <span class="idris-bound">n</span><!-- closing Bound False-->) <span class="idris-bound">a</span><!-- closing Bound False-->)
  <span class="idris-data" title="
Typer ()">SemiColon</span><!-- closing Name Constructor "" "Typer ()"-->
</pre>

#### Minnie

In our last example we present the signature for a function that returns a dependent pair such that the value returned is the minimum value of the two presented arguments.

<pre>
<span class="idris-function" title="
Typer ()">Minnie</span><!-- closing Name Function "" "Typer ()"--> : <span class="idris-type" title="
Type -> Type">Typer</span><!-- closing Name TypeConstructor "" "Type -> Type"--> <span class="idris-type" title="The canonical single-element type, also known as
the trivially true proposition.
Type">()</span><!-- closing Name TypeConstructor "The canonical single-element type, also known as\nthe trivially true proposition." "Type"-->
<span class="idris-function" title="
Typer ()">Minnie</span><!-- closing Name Function "" "Typer ()"--> = <span class="idris-keyword">do</span><!-- closing Keyword-->
  <span class="idris-bound">x</span><!-- closing Bound False--> &lt;- <span class="idris-data" title="
(type : Type) -> Maybe String -> Typer type">Param</span><!-- closing Name Constructor "" "(type : Type) -> Maybe String -> Typer type"--> <span class="idris-type" title="Natural numbers: unbounded, unsigned integers
which can be pattern matched.
Type">Nat</span><!-- closing Name TypeConstructor "Natural numbers: unbounded, unsigned integers\nwhich can be pattern matched." "Type"--> <span class="idris-data" title="No value stored
Maybe a">Nothing</span><!-- closing Name Constructor "No value stored" "Maybe a"-->
  <span class="idris-bound">y</span><!-- closing Bound False--> &lt;- <span class="idris-data" title="
(type : Type) -> Maybe String -> Typer type">Param</span><!-- closing Name Constructor "" "(type : Type) -> Maybe String -> Typer type"--> <span class="idris-type" title="Natural numbers: unbounded, unsigned integers
which can be pattern matched.
Type">Nat</span><!-- closing Name TypeConstructor "Natural numbers: unbounded, unsigned integers\nwhich can be pattern matched." "Type"--> <span class="idris-data" title="No value stored
Maybe a">Nothing</span><!-- closing Name Constructor "No value stored" "Maybe a"-->
  <span class="idris-data" title="
(type : Type) -> Typer type">Return</span><!-- closing Name Constructor "" "(type : Type) -> Typer type"--> <span class="idris-type" title="Dependent pairs aid in the construction of
dependent types by providing evidence that some
value resides in the type.
(a : Type) -> (a -> Type) -> Type">(<span class="idris-bound">z</span><!-- closing Bound False--></span><!-- closing Name TypeConstructor "Dependent pairs aid in the construction of\ndependent types by providing evidence that some\nvalue resides in the type." "(a : Type) -> (a -> Type) -> Type"--> <span class="idris-type" title="Dependent pairs aid in the construction of
dependent types by providing evidence that some
value resides in the type.
(a : Type) -> (a -> Type) -> Type">**</span><!-- closing Name TypeConstructor "Dependent pairs aid in the construction of\ndependent types by providing evidence that some\nvalue resides in the type." "(a : Type) -> (a -> Type) -> Type"--> <span class="idris-bound">z</span><!-- closing Bound False--> <span class="idris-type" title="The propositional equality type. A proof that x =
y.
A -> B -> Type">=</span><!-- closing Name TypeConstructor "The propositional equality type. A proof that x =\ny." "A -> B -> Type"--> <span class="idris-function" title="
Ord ty => ty -> ty -> ty">min</span><!-- closing Name Function "" "Ord ty => ty -> ty -> ty"--> <span class="idris-bound">x</span><!-- closing Bound False--> <span class="idris-bound">y<span class="idris-type" title="Dependent pairs aid in the construction of
dependent types by providing evidence that some
value resides in the type.
(a : Type) -> (a -> Type) -> Type">)</span><!-- closing Name TypeConstructor "Dependent pairs aid in the construction of\ndependent types by providing evidence that some\nvalue resides in the type." "(a : Type) -> (a -> Type) -> Type"--></span><!-- closing Bound False-->
  <span class="idris-data" title="
Typer ()">SemiColon</span><!-- closing Name Constructor "" "Typer ()"-->
</pre>


## Compiling Typer

We can use `Typer` to compute a continuation based data structure (`AType`) to describe our type signature.
We can then use `AType` instances to build type signatures.
We define `AType` as follows:

<pre>
<span class="idris-keyword">data</span><!-- closing Keyword--> <span class="idris-type" title="
Type">AType</span><!-- closing Name TypeConstructor "" "Type"--> : <span class="idris-type" title="The type of types
Type">Type</span><!-- closing Name TypeConstructor "The type of types" "Type"--> <span class="idris-keyword">where</span><!-- closing Keyword-->
  <span class="idris-data" title="
(type : Type) -> (type -> AType) -> AType">P</span><!-- closing Name Constructor "" "(type : Type) -> (type -> AType) -> AType"--> : (<span class="idris-bound">type</span><!-- closing Bound False--> : <span class="idris-type" title="The type of types
Type">Type</span><!-- closing Name TypeConstructor "The type of types" "Type"-->) -&gt; (<span class="idris-bound">type</span><!-- closing Bound False--> -&gt; <span class="idris-type" title="
Type">AType</span><!-- closing Name TypeConstructor "" "Type"-->) -&gt; <span class="idris-type" title="
Type">AType</span><!-- closing Name TypeConstructor "" "Type"-->
  <span class="idris-data" title="
Type -> AType">R</span><!-- closing Name Constructor "" "Type -> AType"--> : (<span class="idris-bound">type</span><!-- closing Bound False--> : <span class="idris-type" title="The type of types
Type">Type</span><!-- closing Name TypeConstructor "The type of types" "Type"-->) -&gt; <span class="idris-type" title="
Type">AType</span><!-- closing Name TypeConstructor "" "Type"-->
  <span class="idris-data" title="
AType">Stop</span><!-- closing Name Constructor "" "AType"--> : <span class="idris-type" title="
Type">AType</span><!-- closing Name TypeConstructor "" "Type"-->
</pre>

`AType` represents a continuation that sequences a series of parameters (`P`) and ends with a return type `R`.
We need `Stop` here for totality reasons even though the continuation ends with `R`.
We can build `AType` instances using `Typer` using the following function:

<pre>
<span class="idris-function" title="
Typer a -> (a -> AType) -> AType">build</span><!-- closing Name Function "" "Typer a -> (a -> AType) -> AType"--> : <span class="idris-type" title="
Type -> Type">Typer</span><!-- closing Name TypeConstructor "" "Type -> Type"--> <span class="idris-bound">a</span><!-- closing Bound False--> -&gt; (<span class="idris-bound">k</span><!-- closing Bound False--> : <span class="idris-bound">a</span><!-- closing Bound False--> -&gt; <span class="idris-type" title="
Type">AType</span><!-- closing Name TypeConstructor "" "Type"-->) -&gt; <span class="idris-type" title="
Type">AType</span><!-- closing Name TypeConstructor "" "Type"-->
<span class="idris-function" title="
Typer a -> (a -> AType) -> AType">build</span><!-- closing Name Function "" "Typer a -> (a -> AType) -> AType"--> (<span class="idris-data" title="
Typer a -> (a -> Typer b) -> Typer b">Let</span><!-- closing Name Constructor "" "Typer a -> (a -> Typer b) -> Typer b"--> <span class="idris-bound">x</span><!-- closing Bound False--> <span class="idris-bound">f</span><!-- closing Bound False-->)   <span class="idris-bound">k</span><!-- closing Bound False--> = <span class="idris-function" title="
Typer a -> (a -> AType) -> AType">build</span><!-- closing Name Function "" "Typer a -> (a -> AType) -> AType"--> <span class="idris-bound">x</span><!-- closing Bound False--> (\<span class="idris-bound">a'</span><!-- closing Bound False--> =&gt; <span class="idris-function" title="
Typer a -> (a -> AType) -> AType">build</span><!-- closing Name Function "" "Typer a -> (a -> AType) -> AType"--> (<span class="idris-bound">f</span><!-- closing Bound False--> <span class="idris-bound">a'</span><!-- closing Bound False-->) <span class="idris-bound">k</span><!-- closing Bound False-->)
<span class="idris-function" title="
Typer a -> (a -> AType) -> AType">build</span><!-- closing Name Function "" "Typer a -> (a -> AType) -> AType"--> (<span class="idris-data" title="
(type : Type) -> Typer type">Return</span><!-- closing Name Constructor "" "(type : Type) -> Typer type"--> <span class="idris-bound">a</span><!-- closing Bound False-->)  <span class="idris-bound">k</span><!-- closing Bound False--> = <span class="idris-data" title="
Type -> AType">R</span><!-- closing Name Constructor "" "Type -> AType"--> <span class="idris-bound">a</span><!-- closing Bound False-->
<span class="idris-function" title="
Typer a -> (a -> AType) -> AType">build</span><!-- closing Name Function "" "Typer a -> (a -> AType) -> AType"--> (<span class="idris-data" title="
(type : Type) -> Maybe String -> Typer type">Param</span><!-- closing Name Constructor "" "(type : Type) -> Maybe String -> Typer type"--> <span class="idris-bound">a</span><!-- closing Bound False--> <span class="idris-bound">x</span><!-- closing Bound False-->) <span class="idris-bound">k</span><!-- closing Bound False--> = <span class="idris-data" title="
(type : Type) -> (type -> AType) -> AType">P</span><!-- closing Name Constructor "" "(type : Type) -> (type -> AType) -> AType"--> <span class="idris-bound">a</span><!-- closing Bound False--> <span class="idris-bound">k</span><!-- closing Bound False-->
<span class="idris-function" title="
Typer a -> (a -> AType) -> AType">build</span><!-- closing Name Function "" "Typer a -> (a -> AType) -> AType"--> <span class="idris-data" title="
Typer ()">SemiColon</span><!-- closing Name Constructor "" "Typer ()"-->   <span class="idris-bound">k</span><!-- closing Bound False--> = <span class="idris-bound">k</span><!-- closing Bound False--> <span class="idris-data" title="The trivial constructor for ().
()">()</span><!-- closing Name Constructor "The trivial constructor for ()." "()"-->
</pre>

As types are first class We can execute (*run*) `AType` instances to compute real type signatures.

<pre>
<span class="idris-function" title="
AType -> Type">run</span><!-- closing Name Function "" "AType -> Type"--> : <span class="idris-type" title="
Type">AType</span><!-- closing Name TypeConstructor "" "Type"--> -&gt; <span class="idris-type" title="The type of types
Type">Type</span><!-- closing Name TypeConstructor "The type of types" "Type"-->
<span class="idris-function" title="
AType -> Type">run</span><!-- closing Name Function "" "AType -> Type"--> (<span class="idris-data" title="
(type : Type) -> (type -> AType) -> AType">P</span><!-- closing Name Constructor "" "(type : Type) -> (type -> AType) -> AType"--> <span class="idris-bound">type</span><!-- closing Bound False--> <span class="idris-bound">f</span><!-- closing Bound False-->) = (<span class="idris-bound">v</span><!-- closing Bound False--> : <span class="idris-bound">type</span><!-- closing Bound False-->) -&gt; (<span class="idris-function" title="
AType -> Type">run</span><!-- closing Name Function "" "AType -> Type"--> (<span class="idris-bound">f</span><!-- closing Bound False--> <span class="idris-bound">v</span><!-- closing Bound False-->))
<span class="idris-function" title="
AType -> Type">run</span><!-- closing Name Function "" "AType -> Type"--> (<span class="idris-data" title="
Type -> AType">R</span><!-- closing Name Constructor "" "Type -> AType"--> <span class="idris-bound">type</span><!-- closing Bound False-->)   = <span class="idris-bound">type</span><!-- closing Bound False-->
<span class="idris-function" title="
AType -> Type">run</span><!-- closing Name Function "" "AType -> Type"--> <span class="idris-data" title="
AType">Stop</span><!-- closing Name Constructor "" "AType"-->       = <span class="idris-type" title="The canonical single-element type, also known as
the trivially true proposition.
Type">()</span><!-- closing Name TypeConstructor "The canonical single-element type, also known as\nthe trivially true proposition." "Type"-->
</pre>

Notice how we bind the name of a parameter to a value and pass it on to help compute the next argument or return type.
We can combine `build` and `run` into `type` to make lives easier.


<pre>
<span class="idris-function" title="
Typer () -> Type">type</span><!-- closing Name Function "" "Typer () -> Type"--> : <span class="idris-type" title="
Type -> Type">Typer</span><!-- closing Name TypeConstructor "" "Type -> Type"--> <span class="idris-type" title="The canonical single-element type, also known as
the trivially true proposition.
Type">()</span><!-- closing Name TypeConstructor "The canonical single-element type, also known as\nthe trivially true proposition." "Type"--> -&gt; <span class="idris-type" title="The type of types
Type">Type</span><!-- closing Name TypeConstructor "The type of types" "Type"-->
<span class="idris-function" title="
Typer () -> Type">type</span><!-- closing Name Function "" "Typer () -> Type"--> <span class="idris-bound">t</span><!-- closing Bound False--> = <span class="idris-function" title="
AType -> Type">run</span><!-- closing Name Function "" "AType -> Type"--> (<span class="idris-function" title="
Typer a -> (a -> AType) -> AType">build</span><!-- closing Name Function "" "Typer a -> (a -> AType) -> AType"--> <span class="idris-bound">t</span><!-- closing Bound False--> (<span class="idris-function" title="Constant function. Ignores its second argument.
a -> b -> a">const</span><!-- closing Name Function "Constant function. Ignores its second argument." "a -> b -> a"--> <span class="idris-data" title="
AType">Stop</span><!-- closing Name Constructor "" "AType"-->))
</pre>

We need `Stop` here to provide a termination point to the signature, as we don't know what the final return type will be.
This mirrors the role of `SemiColon`.

Using `type` we can compute the concrete type signatures for our previous examples.

## Now for something completely different

Rather than compute concrete type signatures we can define a secondary Resource Dependent EDSL to use `AType` instances as a contract to help ensure that a program's arguments and return type match the specification.
In a way this is type-checking a program by construction[^1].

We define `Prog` our EDSL within a `namespace` to allow constructor name reuse[^2].

<pre>
<span class="idris-keyword">namespace</span><!-- closing Keyword--> Prog
  <span class="idris-keyword">data</span><!-- closing Keyword--> <span class="idris-type" title="
(type : Type) -> AType -> (type -> AType) -> Type">Prog</span><!-- closing Name TypeConstructor "" "(type : Type) -> AType -> (type -> AType) -> Type"--> : (<span class="idris-bound">type</span><!-- closing Bound False--> : <span class="idris-type" title="The type of types
Type">Type</span><!-- closing Name TypeConstructor "The type of types" "Type"-->) -&gt; <span class="idris-type" title="
Type">AType</span><!-- closing Name TypeConstructor "" "Type"--> -&gt; (<span class="idris-bound">type</span><!-- closing Bound False--> -&gt; <span class="idris-type" title="
Type">AType</span><!-- closing Name TypeConstructor "" "Type"-->) -&gt; <span class="idris-type" title="The type of types
Type">Type</span><!-- closing Name TypeConstructor "The type of types" "Type"--> <span class="idris-keyword">where</span><!-- closing Keyword-->
    <span class="idris-data" title="
Prog typeA f s ->
((val : typeA) -> Prog typeB (s val) t) ->
Prog typeB f t">Let</span><!-- closing Name Constructor "" "Prog typeA f s ->\n((val : typeA) -> Prog typeB (s val) t) ->\nProg typeB f t"--> : <span class="idris-type" title="
(type : Type) -> AType -> (type -> AType) -> Type">Prog</span><!-- closing Name TypeConstructor "" "(type : Type) -> AType -> (type -> AType) -> Type"--> <span class="idris-bound">typeA</span><!-- closing Bound False--> <span class="idris-bound">f</span><!-- closing Bound False--> <span class="idris-bound">s</span><!-- closing Bound False--> -&gt; ((<span class="idris-bound">val</span><!-- closing Bound False--> : <span class="idris-bound">typeA</span><!-- closing Bound False-->) -&gt; <span class="idris-type" title="
(type : Type) -> AType -> (type -> AType) -> Type">Prog</span><!-- closing Name TypeConstructor "" "(type : Type) -> AType -> (type -> AType) -> Type"--> <span class="idris-bound">typeB</span><!-- closing Bound False--> (<span class="idris-bound">s</span><!-- closing Bound False--> <span class="idris-bound">val</span><!-- closing Bound False-->) <span class="idris-bound">t</span><!-- closing Bound False-->) -&gt; <span class="idris-type" title="
(type : Type) -> AType -> (type -> AType) -> Type">Prog</span><!-- closing Name TypeConstructor "" "(type : Type) -> AType -> (type -> AType) -> Type"--> <span class="idris-bound">typeB</span><!-- closing Bound False--> <span class="idris-bound">f</span><!-- closing Bound False--> <span class="idris-bound">t</span><!-- closing Bound False-->
    <span class="idris-data" title="
type -> Prog type (R type) (const Stop)">Pure</span><!-- closing Name Constructor "" "type -> Prog type (R type) (const Stop)"--> : (<span class="idris-bound">val</span><!-- closing Bound False--> : <span class="idris-bound">type</span><!-- closing Bound False-->) -&gt; <span class="idris-type" title="
(type : Type) -> AType -> (type -> AType) -> Type">Prog</span><!-- closing Name TypeConstructor "" "(type : Type) -> AType -> (type -> AType) -> Type"--> <span class="idris-bound">type</span><!-- closing Bound False--> (<span class="idris-data" title="
Type -> AType">R</span><!-- closing Name Constructor "" "Type -> AType"--> <span class="idris-bound">type</span><!-- closing Bound False-->) (<span class="idris-function" title="Constant function. Ignores its second argument.
a -> b -> a">const</span><!-- closing Name Function "Constant function. Ignores its second argument." "a -> b -> a"--> <span class="idris-data" title="
AType">Stop</span><!-- closing Name Constructor "" "AType"-->)
    <span class="idris-data" title="
Prog () Stop (const Stop)">SemiColon</span><!-- closing Name Constructor "" "Prog () Stop (const Stop)"--> : <span class="idris-type" title="
(type : Type) -> AType -> (type -> AType) -> Type">Prog</span><!-- closing Name TypeConstructor "" "(type : Type) -> AType -> (type -> AType) -> Type"--> <span class="idris-type" title="The canonical single-element type, also known as
the trivially true proposition.
Type">()</span><!-- closing Name TypeConstructor "The canonical single-element type, also known as\nthe trivially true proposition." "Type"--> <span class="idris-data" title="
AType">Stop</span><!-- closing Name Constructor "" "AType"--> (<span class="idris-function" title="Constant function. Ignores its second argument.
a -> b -> a">const</span><!-- closing Name Function "Constant function. Ignores its second argument." "a -> b -> a"--> <span class="idris-data" title="
AType">Stop</span><!-- closing Name Constructor "" "AType"-->)
    <span class="idris-data" title="
type -> Prog type (P type k) k">Arg</span><!-- closing Name Constructor "" "type -> Prog type (P type k) k"--> : (<span class="idris-bound">val</span><!-- closing Bound False--> : <span class="idris-bound">type</span><!-- closing Bound False-->) -&gt; <span class="idris-type" title="
(type : Type) -> AType -> (type -> AType) -> Type">Prog</span><!-- closing Name TypeConstructor "" "(type : Type) -> AType -> (type -> AType) -> Type"--> <span class="idris-bound">type</span><!-- closing Bound False--> (<span class="idris-data" title="
(type : Type) -> (type -> AType) -> AType">P</span><!-- closing Name Constructor "" "(type : Type) -> (type -> AType) -> AType"--> <span class="idris-bound">type</span><!-- closing Bound False--> <span class="idris-bound">k</span><!-- closing Bound False-->) <span class="idris-bound">k</span><!-- closing Bound False-->
</pre>

`Prog` is a resource dependent EDSL that computes `AType` instances within its type.
This ensures that the sequencing of data constructors **must** match the ordering as presented by an `AType` continuation.

`Let` allows us to sequence expressions and ensures that the continuation embedded within `AType` is correctly executed.
`Pure` is the return value and it's value **must** have the same type as presented by the `R` constructor of `AType`.
It's next state is `Stop`.
`Arg` represents a parameter and as with `Pure` it's value **must** have the same type as specified by the `P` constructor of `AType`.
Further, the type of `Prog` and the continuation embedded within the constructor `P` represents the next value in the sequence.
`SemiColon` is required to provide a termination point to the function body.

Notice that `SemiColon` has to be provided after a `Pure` constructor, and that we can only get to a `Pure` constructor by stepping through the continuation embedded within `AType`.
This is how the ordering (sequenced using `Let`) in `Prog` is dictated by `AType`.

We provide implementations, as required, to `(>>=)` and `pure` for Do-notation.

<pre>
  <span class="idris-function" title="
Prog typeA f s ->
((val : typeA) -> Prog typeB (s val) t) ->
Prog typeB f t">(&gt;&gt;=)</span><!-- closing Name Function "" "Prog typeA f s ->\n((val : typeA) -> Prog typeB (s val) t) ->\nProg typeB f t"--> : <span class="idris-type" title="
(type : Type) -> AType -> (type -> AType) -> Type">Prog</span><!-- closing Name TypeConstructor "" "(type : Type) -> AType -> (type -> AType) -> Type"--> <span class="idris-bound">typeA</span><!-- closing Bound False--> <span class="idris-bound">f</span><!-- closing Bound False--> <span class="idris-bound">s</span><!-- closing Bound False--> -&gt; ((<span class="idris-bound">val</span><!-- closing Bound False--> : <span class="idris-bound">typeA</span><!-- closing Bound False-->) -&gt; <span class="idris-type" title="
(type : Type) -> AType -> (type -> AType) -> Type">Prog</span><!-- closing Name TypeConstructor "" "(type : Type) -> AType -> (type -> AType) -> Type"--> <span class="idris-bound">typeB</span><!-- closing Bound False--> (<span class="idris-bound">s</span><!-- closing Bound False--> <span class="idris-bound">val</span><!-- closing Bound False-->) <span class="idris-bound">t</span><!-- closing Bound False-->) -&gt; <span class="idris-type" title="
(type : Type) -> AType -> (type -> AType) -> Type">Prog</span><!-- closing Name TypeConstructor "" "(type : Type) -> AType -> (type -> AType) -> Type"--> <span class="idris-bound">typeB</span><!-- closing Bound False--> <span class="idris-bound">f</span><!-- closing Bound False--> <span class="idris-bound">t</span><!-- closing Bound False-->
  <span class="idris-function" title="
Prog typeA f s ->
((val : typeA) -> Prog typeB (s val) t) ->
Prog typeB f t">(&gt;&gt;=)</span><!-- closing Name Function "" "Prog typeA f s ->\n((val : typeA) -> Prog typeB (s val) t) ->\nProg typeB f t"--> = <span class="idris-data" title="
Prog typeA f s ->
((val : typeA) -> Prog typeB (s val) t) ->
Prog typeB f t">Prog.Let</span><!-- closing Name Constructor "" "Prog typeA f s ->\n((val : typeA) -> Prog typeB (s val) t) ->\nProg typeB f t"-->

  <span class="idris-function" title="
type -> Prog type (R type) (const Stop)">pure</span><!-- closing Name Function "" "type -> Prog type (R type) (const Stop)"--> : (<span class="idris-bound">val</span><!-- closing Bound False--> : <span class="idris-bound">type</span><!-- closing Bound False-->) -&gt; <span class="idris-type" title="
(type : Type) -> AType -> (type -> AType) -> Type">Prog</span><!-- closing Name TypeConstructor "" "(type : Type) -> AType -> (type -> AType) -> Type"--> <span class="idris-bound">type</span><!-- closing Bound False--> (<span class="idris-data" title="
Type -> AType">R</span><!-- closing Name Constructor "" "Type -> AType"--> <span class="idris-bound">type</span><!-- closing Bound False-->) (<span class="idris-function" title="Constant function. Ignores its second argument.
a -> b -> a">const</span><!-- closing Name Function "Constant function. Ignores its second argument." "a -> b -> a"--> <span class="idris-data" title="
AType">Stop</span><!-- closing Name Constructor "" "AType"-->)
  <span class="idris-function" title="
type -> Prog type (R type) (const Stop)">pure</span><!-- closing Name Function "" "type -> Prog type (R type) (const Stop)"--> = <span class="idris-data" title="
type -> Prog type (R type) (const Stop)">Pure</span><!-- closing Name Constructor "" "type -> Prog type (R type) (const Stop)"-->
</pre>

We can now construct a function `typeDef` to dictate the initial and final states of a  `program`.

<pre>
  <span class="idris-function" title="
Typer () -> Type">typeDef</span><!-- closing Name Function "" "Typer () -> Type"--> : <span class="idris-type" title="
Type -> Type">Typer</span><!-- closing Name TypeConstructor "" "Type -> Type"--> <span class="idris-type" title="The canonical single-element type, also known as
the trivially true proposition.
Type">()</span><!-- closing Name TypeConstructor "The canonical single-element type, also known as\nthe trivially true proposition." "Type"--> -&gt; <span class="idris-type" title="The type of types
Type">Type</span><!-- closing Name TypeConstructor "The type of types" "Type"-->
  <span class="idris-function" title="
Typer () -> Type">typeDef</span><!-- closing Name Function "" "Typer () -> Type"--> <span class="idris-bound">type</span><!-- closing Bound False--> = <span class="idris-type" title="
(type : Type) -> AType -> (type -> AType) -> Type">Prog</span><!-- closing Name TypeConstructor "" "(type : Type) -> AType -> (type -> AType) -> Type"--> <span class="idris-type" title="The canonical single-element type, also known as
the trivially true proposition.
Type">()</span><!-- closing Name TypeConstructor "The canonical single-element type, also known as\nthe trivially true proposition." "Type"--> (<span class="idris-function" title="
Typer a -> (a -> AType) -> AType">build</span><!-- closing Name Function "" "Typer a -> (a -> AType) -> AType"--> <span class="idris-bound">type</span><!-- closing Bound False--> (<span class="idris-function" title="Constant function. Ignores its second argument.
a -> b -> a">const</span><!-- closing Name Function "Constant function. Ignores its second argument." "a -> b -> a"--> <span class="idris-data" title="
AType">Stop</span><!-- closing Name Constructor "" "AType"-->)) (<span class="idris-function" title="Constant function. Ignores its second argument.
a -> b -> a">const</span><!-- closing Name Function "Constant function. Ignores its second argument." "a -> b -> a"--> <span class="idris-data" title="
AType">Stop</span><!-- closing Name Constructor "" "AType"-->)
</pre>

`typeDef` uses the provided specification to `build` an `AType` instance that represents the initial state with final value of `Stop`, and we ask that our final state is `Stop`.

### An Example

We finish with an example that uses `Append 4 3 Nat` as a specification to type check against.

<pre>
  <span class="idris-function" title="
typeDef (Append 4 3 Nat)">append</span><!-- closing Name Function "" "typeDef (Append 4 3 Nat)"--> : (<span class="idris-function" title="
Typer () -> Type">typeDef</span><!-- closing Name Function "" "Typer () -> Type"--> (<span class="idris-function" title="
Nat -> Nat -> Type -> Typer ()">Append</span><!-- closing Name Function "" "Nat -> Nat -> Type -> Typer ()"--> <span class="idris-function" title="Conversion from Integer.
Num ty => Integer -> ty"><span class="idris-data" title="Successor
Nat -> Nat">4</span><!-- closing Name Constructor "Successor" "Nat -> Nat"--></span><!-- closing Name Function "Conversion from Integer." "Num ty => Integer -> ty"--> <span class="idris-function" title="Conversion from Integer.
Num ty => Integer -> ty"><span class="idris-data" title="Successor
Nat -> Nat">3</span><!-- closing Name Constructor "Successor" "Nat -> Nat"--></span><!-- closing Name Function "Conversion from Integer." "Num ty => Integer -> ty"--> <span class="idris-type" title="Natural numbers: unbounded, unsigned integers
which can be pattern matched.
Type">Nat</span><!-- closing Name TypeConstructor "Natural numbers: unbounded, unsigned integers\nwhich can be pattern matched." "Type"-->))
  <span class="idris-function" title="
typeDef (Append 4 3 Nat)">append</span><!-- closing Name Function "" "typeDef (Append 4 3 Nat)"--> = <span class="idris-keyword">do</span><!-- closing Keyword-->
    <span class="idris-bound">xs</span><!-- closing Bound False--> &lt;- <span class="idris-data" title="
type -> Prog type (P type k) k">Arg</span><!-- closing Name Constructor "" "type -> Prog type (P type k) k"--> (<span class="idris-function" title="Manually assign a type to an expression.
(a : Type) -> a -> a">the</span><!-- closing Name Function "Manually assign a type to an expression." "(a : Type) -> a -> a"--> (<span class="idris-type" title="Vectors: Generic lists with explicit length in the
type
Nat -> Type -> Type">Vect</span><!-- closing Name TypeConstructor "Vectors: Generic lists with explicit length in the\ntype" "Nat -> Type -> Type"--> <span class="idris-function" title="Conversion from Integer.
Num ty => Integer -> ty"><span class="idris-data" title="Successor
Nat -> Nat">4</span><!-- closing Name Constructor "Successor" "Nat -> Nat"--></span><!-- closing Name Function "Conversion from Integer." "Num ty => Integer -> ty"--> <span class="idris-type" title="Natural numbers: unbounded, unsigned integers
which can be pattern matched.
Type">Nat</span><!-- closing Name TypeConstructor "Natural numbers: unbounded, unsigned integers\nwhich can be pattern matched." "Type"-->) <span class="idris-data" title="A non-empty vector of length S len, consisting of
a head element and the rest of the list, of length
len.
elem -> Vect len elem -> Vect (S len) elem">[<span class="idris-function" title="Conversion from Integer.
Num ty => Integer -> ty"><span class="idris-data" title="Successor
Nat -> Nat">1<span class="idris-data" title="A non-empty vector of length S len, consisting of
a head element and the rest of the list, of length
len.
elem -> Vect len elem -> Vect (S len) elem">,<span class="idris-function" title="Conversion from Integer.
Num ty => Integer -> ty"><span class="idris-data" title="Successor
Nat -> Nat">2<span class="idris-data" title="A non-empty vector of length S len, consisting of
a head element and the rest of the list, of length
len.
elem -> Vect len elem -> Vect (S len) elem">,<span class="idris-function" title="Conversion from Integer.
Num ty => Integer -> ty"><span class="idris-data" title="Successor
Nat -> Nat">3<span class="idris-data" title="A non-empty vector of length S len, consisting of
a head element and the rest of the list, of length
len.
elem -> Vect len elem -> Vect (S len) elem">,<span class="idris-function" title="Conversion from Integer.
Num ty => Integer -> ty"><span class="idris-data" title="Successor
Nat -> Nat">4<span class="idris-data" title="Empty vector
Vect 0 elem">]</span><!-- closing Name Constructor "Empty vector" "Vect 0 elem"--></span><!-- closing Name Constructor "Successor" "Nat -> Nat"--></span><!-- closing Name Function "Conversion from Integer." "Num ty => Integer -> ty"--></span><!-- closing Name Constructor "A non-empty vector of length S len, consisting of\na head element and the rest of the list, of length\nlen." "elem -> Vect len elem -> Vect (S len) elem"--></span><!-- closing Name Constructor "Successor" "Nat -> Nat"--></span><!-- closing Name Function "Conversion from Integer." "Num ty => Integer -> ty"--></span><!-- closing Name Constructor "A non-empty vector of length S len, consisting of\na head element and the rest of the list, of length\nlen." "elem -> Vect len elem -> Vect (S len) elem"--></span><!-- closing Name Constructor "Successor" "Nat -> Nat"--></span><!-- closing Name Function "Conversion from Integer." "Num ty => Integer -> ty"--></span><!-- closing Name Constructor "A non-empty vector of length S len, consisting of\na head element and the rest of the list, of length\nlen." "elem -> Vect len elem -> Vect (S len) elem"--></span><!-- closing Name Constructor "Successor" "Nat -> Nat"--></span><!-- closing Name Function "Conversion from Integer." "Num ty => Integer -> ty"--></span><!-- closing Name Constructor "A non-empty vector of length S len, consisting of\na head element and the rest of the list, of length\nlen." "elem -> Vect len elem -> Vect (S len) elem"-->)
    <span class="idris-bound">ys</span><!-- closing Bound False--> &lt;- <span class="idris-data" title="
type -> Prog type (P type k) k">Arg</span><!-- closing Name Constructor "" "type -> Prog type (P type k) k"--> (<span class="idris-function" title="Manually assign a type to an expression.
(a : Type) -> a -> a">the</span><!-- closing Name Function "Manually assign a type to an expression." "(a : Type) -> a -> a"--> (<span class="idris-type" title="Vectors: Generic lists with explicit length in the
type
Nat -> Type -> Type">Vect</span><!-- closing Name TypeConstructor "Vectors: Generic lists with explicit length in the\ntype" "Nat -> Type -> Type"--> <span class="idris-function" title="Conversion from Integer.
Num ty => Integer -> ty"><span class="idris-data" title="Successor
Nat -> Nat">3</span><!-- closing Name Constructor "Successor" "Nat -> Nat"--></span><!-- closing Name Function "Conversion from Integer." "Num ty => Integer -> ty"--> <span class="idris-type" title="Natural numbers: unbounded, unsigned integers
which can be pattern matched.
Type">Nat</span><!-- closing Name TypeConstructor "Natural numbers: unbounded, unsigned integers\nwhich can be pattern matched." "Type"-->) <span class="idris-data" title="A non-empty vector of length S len, consisting of
a head element and the rest of the list, of length
len.
elem -> Vect len elem -> Vect (S len) elem">[<span class="idris-function" title="Conversion from Integer.
Num ty => Integer -> ty"><span class="idris-data" title="Successor
Nat -> Nat">1<span class="idris-data" title="A non-empty vector of length S len, consisting of
a head element and the rest of the list, of length
len.
elem -> Vect len elem -> Vect (S len) elem">,<span class="idris-function" title="Conversion from Integer.
Num ty => Integer -> ty"><span class="idris-data" title="Successor
Nat -> Nat">2<span class="idris-data" title="A non-empty vector of length S len, consisting of
a head element and the rest of the list, of length
len.
elem -> Vect len elem -> Vect (S len) elem">,<span class="idris-function" title="Conversion from Integer.
Num ty => Integer -> ty"><span class="idris-data" title="Successor
Nat -> Nat">3<span class="idris-data" title="Empty vector
Vect 0 elem">]</span><!-- closing Name Constructor "Empty vector" "Vect 0 elem"--></span><!-- closing Name Constructor "Successor" "Nat -> Nat"--></span><!-- closing Name Function "Conversion from Integer." "Num ty => Integer -> ty"--></span><!-- closing Name Constructor "A non-empty vector of length S len, consisting of\na head element and the rest of the list, of length\nlen." "elem -> Vect len elem -> Vect (S len) elem"--></span><!-- closing Name Constructor "Successor" "Nat -> Nat"--></span><!-- closing Name Function "Conversion from Integer." "Num ty => Integer -> ty"--></span><!-- closing Name Constructor "A non-empty vector of length S len, consisting of\na head element and the rest of the list, of length\nlen." "elem -> Vect len elem -> Vect (S len) elem"--></span><!-- closing Name Constructor "Successor" "Nat -> Nat"--></span><!-- closing Name Function "Conversion from Integer." "Num ty => Integer -> ty"--></span><!-- closing Name Constructor "A non-empty vector of length S len, consisting of\na head element and the rest of the list, of length\nlen." "elem -> Vect len elem -> Vect (S len) elem"-->)
    <span class="idris-function" title="
type -> Prog type (R type) (const Stop)">pure</span><!-- closing Name Function "" "type -> Prog type (R type) (const Stop)"--> (<span class="idris-bound">xs</span><!-- closing Bound False--> <span class="idris-function" title="Append two vectors
Vect m elem -> Vect n elem -> Vect (m + n) elem">++</span><!-- closing Name Function "Append two vectors" "Vect m elem -> Vect n elem -> Vect (m + n) elem"--> <span class="idris-bound">ys</span><!-- closing Bound False-->)
    <span class="idris-data" title="
Prog () Stop (const Stop)">SemiColon</span><!-- closing Name Constructor "" "Prog () Stop (const Stop)"-->
</pre>


## Coda

This was a simple example on how to use dependent types to do some interesting computations relating to constructing program specifications, and subsequently verification an implementation against a specification.
We can extend the example in many ways to tighten the specification correctness but also enhance the expressiveness of our programs.
I reckon we could do something interesting with this construction, as to how interesting for publication I am not sure.
Sometimes, it is hard for me to tell if what I do is truely novel, or for another Dependently Typed Programmer to go: *this is just x*.

Regardless, the example construction here is a popular design pattern within my Idris programs to provide an intrinsic link between a specification and an implementation.
I learned the pattern from a dependent typer I met in a bar, and rather truthfully I am not sure how interesting it would be to write this up with them.


[^1]: I wonder what more experienced typers will think of that statement.
[^2]: I also cannot be bother to go through the HTML and fix the pretty printing.
